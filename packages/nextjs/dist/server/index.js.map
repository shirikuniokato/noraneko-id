{"version":3,"sources":["../../src/server/index.ts","../../src/server/auth.ts","../../src/server/config.ts","../../src/shared/errors.ts","../../src/shared/utils.ts"],"sourcesContent":["import 'server-only'\n\n// 認証核心機能\nexport { auth, requireAuth, saveSession, clearSession, exchangeCodeForTokens } from './auth'\n\n// 設定機能  \nexport { createAuth, getAuthConfig } from './config'\n\n// Discovery機能（ビルド時）\nexport type { DiscoveryDocument } from './discovery'\n\n// 型定義\nexport type { Session, User, AuthConfig, AuthError } from '../shared/types'\n\n// エラークラス\nexport { \n  NoranekoAuthError, \n  TokenExpiredError, \n  InvalidTokenError, \n  AuthenticationRequiredError,\n  OAuthError \n} from '../shared/errors'","import 'server-only'\nimport { cookies } from 'next/headers'\nimport type { Session, User, TokenResponse, UserInfoResponse } from '../shared/types'\nimport { getAuthConfig, getDiscoveryConfig } from './config'\nimport { \n  AuthenticationRequiredError, \n  TokenExpiredError, \n  InvalidTokenError,\n  OAuthError \n} from '../shared/errors'\nimport { \n  getCookieName, \n  parseCookieValue, \n  serializeCookieValue,\n  isTokenExpired,\n  isTokenExpiringSoon\n} from '../shared/utils'\n\n// NextAuth v5風の統一インターフェース\nexport async function auth(): Promise<Session | null> {\n  try {\n    const config = getAuthConfig()\n    const session = await getSession()\n    \n    if (!session) {\n      return null\n    }\n    \n    // 自動リフレッシュが無効の場合は基本チェックのみ\n    if (!config.autoRefresh?.enabled) {\n      if (isTokenExpired(session.expiresAt)) {\n        await clearSession()\n        return null\n      }\n      return session\n    }\n    \n    // トークンの有効期限チェック（期限切れ）\n    if (isTokenExpired(session.expiresAt)) {\n      if (session.refreshToken) {\n        // リフレッシュトークンでセッション更新を試行（リトライ付き）\n        const refreshed = await refreshSessionWithRetry(\n          session.refreshToken, \n          config.autoRefresh.maxRetries || 3,\n          config.autoRefresh.retryInterval || 5000\n        )\n        if (refreshed) {\n          await saveSession(refreshed)\n          return refreshed\n        }\n      }\n      // リフレッシュ失敗またはリフレッシュトークンがない場合はセッションクリア\n      await clearSession()\n      return null\n    }\n    \n    // 期限が近い場合はバックグラウンドでリフレッシュ\n    const threshold = config.autoRefresh.refreshThreshold || 5 * 60 * 1000\n    if (session.refreshToken && isTokenExpiringSoon(session.expiresAt, threshold)) {\n      // 非同期でリフレッシュ（await しない）\n      refreshSessionWithRetry(\n        session.refreshToken,\n        config.autoRefresh.maxRetries || 3,\n        config.autoRefresh.retryInterval || 5000\n      )\n        .then(refreshed => refreshed && saveSession(refreshed))\n        .catch((error) => {\n          if (config.debug) {\n            console.error('Background token refresh failed:', error)\n          }\n        })\n    }\n    \n    return session\n  } catch (error) {\n    if (getAuthConfig().debug) {\n      console.error('Auth error:', error)\n    }\n    return null\n  }\n}\n\n// 認証必須のヘルパー（NextAuth v5風）\nexport async function requireAuth(): Promise<User> {\n  const session = await auth()\n  if (!session) {\n    throw new AuthenticationRequiredError()\n  }\n  return session.user\n}\n\n// セッション取得（内部関数）\nasync function getSession(): Promise<Session | null> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  const sessionCookie = cookieStore.get(getCookieName(config.cookiePrefix!, 'token'))\n  \n  return parseCookieValue<Session>(sessionCookie?.value)\n}\n\n// セッション保存\nexport async function saveSession(session: Session): Promise<void> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  \n  cookieStore.set(getCookieName(config.cookiePrefix!, 'token'), serializeCookieValue(session), {\n    httpOnly: true,\n    secure: config.cookieSecure,\n    sameSite: 'lax',\n    maxAge: Math.floor((session.expiresAt - Date.now()) / 1000),\n    path: '/'\n  })\n}\n\n// セッションクリア\nexport async function clearSession(): Promise<void> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  \n  cookieStore.delete(getCookieName(config.cookiePrefix!, 'token'))\n}\n\n// OAuth2トークン交換\nexport async function exchangeCodeForTokens(\n  code: string,\n  codeVerifier: string,\n  redirectUri: string\n): Promise<Session> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery) {\n    throw new Error('Discovery configuration not available')\n  }\n  \n  const tokenResponse = await fetch(discovery.token_endpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      client_id: config.clientId,\n      code,\n      redirect_uri: redirectUri,\n      code_verifier: codeVerifier\n    })\n  })\n  \n  if (!tokenResponse.ok) {\n    const error = await tokenResponse.json().catch(() => ({}))\n    throw new OAuthError(error.error || 'token_exchange_failed', error.error_description)\n  }\n  \n  const tokens: TokenResponse = await tokenResponse.json()\n  \n  // ユーザー情報取得\n  const userInfo = await fetchUserInfo(tokens.access_token)\n  \n  // セッション作成\n  const session: Session = {\n    user: {\n      id: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      image: userInfo.picture\n    },\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token,\n    expiresAt: Date.now() + (tokens.expires_in * 1000),\n    scope: tokens.scope\n  }\n  \n  return session\n}\n\n// リフレッシュトークンでセッション更新（リトライ機能付き）\nasync function refreshSessionWithRetry(\n  refreshToken: string, \n  maxRetries: number = 3, \n  retryInterval: number = 5000\n): Promise<Session | null> {\n  let lastError: Error | null = null\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const session = await refreshSession(refreshToken)\n      if (session) {\n        if (getAuthConfig().debug && attempt > 1) {\n          console.log(`Token refresh succeeded on attempt ${attempt}`)\n        }\n        return session\n      }\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('Unknown error')\n      \n      if (getAuthConfig().debug) {\n        console.warn(`Token refresh attempt ${attempt}/${maxRetries} failed:`, lastError.message)\n      }\n      \n      // 最後の試行でなければ待機\n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, retryInterval))\n      }\n    }\n  }\n  \n  if (getAuthConfig().debug) {\n    console.error(`Token refresh failed after ${maxRetries} attempts. Last error:`, lastError?.message)\n  }\n  \n  return null\n}\n\n// リフレッシュトークンでセッション更新（基本実装）\nasync function refreshSession(refreshToken: string): Promise<Session | null> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery) {\n    throw new Error('Discovery configuration not available')\n  }\n  \n  const tokenResponse = await fetch(discovery.token_endpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      client_id: config.clientId,\n      refresh_token: refreshToken\n    })\n  })\n  \n  if (!tokenResponse.ok) {\n    const errorData = await tokenResponse.json().catch(() => ({}))\n    throw new TokenExpiredError(`Failed to refresh token: ${errorData.error || tokenResponse.statusText}`)\n  }\n  \n  const tokens: TokenResponse = await tokenResponse.json()\n  const userInfo = await fetchUserInfo(tokens.access_token)\n  \n  return {\n    user: {\n      id: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      image: userInfo.picture\n    },\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token || refreshToken, // 新しいリフレッシュトークンがなければ既存を使用\n    expiresAt: Date.now() + (tokens.expires_in * 1000),\n    scope: tokens.scope\n  }\n}\n\n// ユーザー情報取得\nasync function fetchUserInfo(accessToken: string): Promise<UserInfoResponse> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery || !discovery.userinfo_endpoint) {\n    throw new Error('Discovery configuration or userinfo endpoint not available')\n  }\n  \n  const userResponse = await fetch(discovery.userinfo_endpoint, {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`\n    }\n  })\n  \n  if (!userResponse.ok) {\n    throw new InvalidTokenError('Failed to fetch user info')\n  }\n  \n  return userResponse.json()\n}","import 'server-only'\nimport type { AuthConfig } from '../shared/types'\nimport type { DiscoveryDocument } from './discovery'\n\nlet globalConfig: AuthConfig | null = null\nlet discoveryConfig: DiscoveryDocument | null = null\n\nexport function setAuthConfig(config: AuthConfig): void {\n  // デフォルト値の設定\n  globalConfig = {\n    scopes: ['openid', 'profile', 'email'],\n    redirectUri: '/api/auth/callback',\n    loginPath: '/api/auth/login',\n    callbackPath: '/api/auth/callback',\n    logoutPath: '/api/auth/logout',\n    cookiePrefix: 'noraneko-auth',\n    cookieSecure: process.env.NODE_ENV === 'production',\n    debug: process.env.NODE_ENV === 'development',\n    autoRefresh: {\n      enabled: true,\n      refreshThreshold: 5 * 60 * 1000,  // 5分前\n      maxRetries: 3,\n      retryInterval: 5 * 1000,          // 5秒間隔\n      ...(config.autoRefresh || {})\n    },\n    ...config\n  }\n  \n  // ビルド時Discoveryの結果を取得\n  const discoveryJson = process.env.NORANEKO_DISCOVERY_CONFIG\n  if (!discoveryJson) {\n    throw new Error(\n      'NORANEKO_DISCOVERY_CONFIG environment variable not found. ' +\n      'Make sure to add the discovery configuration to your next.config.js. ' +\n      'See: https://github.com/noraneko-id/nextjs#build-time-discovery'\n    )\n  }\n  \n  try {\n    discoveryConfig = JSON.parse(discoveryJson)\n    \n    // 基本的な検証\n    if (!discoveryConfig || !discoveryConfig.authorization_endpoint || !discoveryConfig.token_endpoint) {\n      throw new Error('Invalid discovery configuration embedded at build time')\n    }\n    \n    if (config.debug) {\n      console.log('Using build-time OIDC discovery configuration:', {\n        authorization_endpoint: discoveryConfig.authorization_endpoint,\n        token_endpoint: discoveryConfig.token_endpoint,\n        userinfo_endpoint: discoveryConfig.userinfo_endpoint,\n      })\n    }\n  } catch (error) {\n    throw new Error(`Failed to parse discovery configuration: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\n// 環境変数から自動初期化\nfunction initializeFromEnv(): AuthConfig {\n  const issuer = process.env.NORANEKO_ISSUER\n  const clientId = process.env.NORANEKO_CLIENT_ID\n  \n  if (!issuer || !clientId) {\n    throw new Error('NORANEKO_ISSUER and NORANEKO_CLIENT_ID environment variables are required')\n  }\n  \n  return {\n    issuer,\n    clientId,\n    clientSecret: process.env.NORANEKO_CLIENT_SECRET,\n    scopes: ['openid', 'profile', 'email'],\n    redirectUri: '/api/auth/callback',\n    loginPath: '/api/auth/login',\n    callbackPath: '/api/auth/callback',\n    logoutPath: '/api/auth/logout',\n    cookiePrefix: 'noraneko-auth',\n    cookieSecure: process.env.NODE_ENV === 'production',\n    debug: process.env.NODE_ENV === 'development',\n    autoRefresh: {\n      enabled: true,\n      refreshThreshold: 5 * 60 * 1000,  // 5分前\n      maxRetries: 3,\n      retryInterval: 5 * 1000           // 5秒間隔\n    }\n  }\n}\n\nexport function getAuthConfig(): AuthConfig {\n  if (!globalConfig) {\n    // 環境変数から自動初期化を試行\n    try {\n      globalConfig = initializeFromEnv()\n    } catch (error) {\n      throw new Error('Auth config not initialized. Call createAuth() first or set environment variables.')\n    }\n  }\n  return globalConfig\n}\n\nexport function createAuth(config: AuthConfig): void {\n  setAuthConfig(config)\n}\n\nexport function getDiscoveryConfig(): DiscoveryDocument | null {\n  return discoveryConfig\n}","import type { AuthError } from './types'\n\nexport class NoranekoAuthError extends Error implements AuthError {\n  readonly type = 'AuthError' as const\n  \n  constructor(\n    public code: string,\n    message: string,\n    public cause?: Error\n  ) {\n    super(message)\n    this.name = 'NoranekoAuthError'\n  }\n}\n\nexport class TokenExpiredError extends NoranekoAuthError {\n  constructor(message = 'Token has expired') {\n    super('TOKEN_EXPIRED', message)\n  }\n}\n\nexport class InvalidTokenError extends NoranekoAuthError {\n  constructor(message = 'Invalid token') {\n    super('INVALID_TOKEN', message)\n  }\n}\n\nexport class AuthenticationRequiredError extends NoranekoAuthError {\n  constructor(message = 'Authentication required') {\n    super('AUTHENTICATION_REQUIRED', message)\n  }\n}\n\nexport class OAuthError extends NoranekoAuthError {\n  constructor(\n    public oauthError: string,\n    public oauthErrorDescription?: string\n  ) {\n    super('OAUTH_ERROR', `OAuth error: ${oauthError}${oauthErrorDescription ? ` - ${oauthErrorDescription}` : ''}`)\n  }\n}","import crypto from 'crypto'\n\n// PKCE (Proof Key for Code Exchange) utilities\nexport function generateCodeVerifier(): string {\n  return crypto.randomBytes(32).toString('base64url')\n}\n\nexport function generateCodeChallenge(verifier: string): string {\n  return crypto.createHash('sha256').update(verifier).digest('base64url')\n}\n\nexport function generateState(): string {\n  return crypto.randomBytes(16).toString('base64url')\n}\n\n// URL utilities\nexport function buildAuthUrl(config: {\n  issuer: string\n  clientId: string\n  redirectUri: string\n  scopes: string[]\n  state: string\n  codeChallenge: string\n  authorizationEndpoint: string\n}): string {\n  const params = new URLSearchParams({\n    response_type: 'code',\n    client_id: config.clientId,\n    redirect_uri: config.redirectUri,\n    scope: config.scopes.join(' '),\n    state: config.state,\n    code_challenge: config.codeChallenge,\n    code_challenge_method: 'S256'\n  })\n  \n  return `${config.authorizationEndpoint}?${params.toString()}`\n}\n\n// Token utilities\nexport function isTokenExpired(expiresAt: number): boolean {\n  return Date.now() >= expiresAt\n}\n\nexport function isTokenExpiringSoon(expiresAt: number, bufferMs = 60000): boolean {\n  return Date.now() >= (expiresAt - bufferMs)\n}\n\n// Cookie utilities\nexport function getCookieName(prefix: string, name: string): string {\n  return `${prefix}.${name}`\n}\n\nexport function parseCookieValue<T>(value: string | undefined): T | null {\n  if (!value) return null\n  try {\n    return JSON.parse(value)\n  } catch {\n    return null\n  }\n}\n\nexport function serializeCookieValue<T>(value: T): string {\n  return JSON.stringify(value)\n}"],"mappings":"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","names":[]}