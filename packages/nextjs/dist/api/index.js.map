{"version":3,"sources":["../../src/api/handlers/login.ts","../../src/server/config.ts","../../src/shared/utils.ts","../../src/api/handlers/callback.ts","../../src/server/auth.ts","../../src/shared/errors.ts","../../src/api/handlers/logout.ts","../../src/api/handlers/token.ts","../../src/api/handlers.ts","../../src/api/create-handlers.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthConfig, getDiscoveryConfig } from '../../server/config'\nimport { \n  generateCodeVerifier, \n  generateCodeChallenge, \n  generateState, \n  buildAuthUrl,\n  getCookieName,\n  serializeCookieValue\n} from '../../shared/utils'\n\nexport function createLoginHandler() {\n  return async function loginHandler(request: NextRequest) {\n    try {\n      const config = getAuthConfig()\n      const { searchParams } = new URL(request.url)\n      const callbackUrl = searchParams.get('callbackUrl') || '/'\n      \n      // PKCE パラメータ生成\n      const codeVerifier = generateCodeVerifier()\n      const codeChallenge = generateCodeChallenge(codeVerifier)\n      const state = generateState()\n      \n      // 認証URL生成\n      const discovery = getDiscoveryConfig()\n      if (!discovery) {\n        throw new Error('Discovery configuration not available')\n      }\n      \n      const authUrl = buildAuthUrl({\n        issuer: config.issuer,\n        clientId: config.clientId,\n        redirectUri: new URL(config.redirectUri!, request.url).toString(),\n        scopes: config.scopes!,\n        state,\n        codeChallenge,\n        authorizationEndpoint: discovery.authorization_endpoint\n      })\n      \n      // PKCE情報とcallbackUrlをCookieに保存\n      const response = NextResponse.redirect(authUrl)\n      \n      response.cookies.set(\n        getCookieName(config.cookiePrefix!, 'code_verifier'),\n        codeVerifier,\n        {\n          httpOnly: true,\n          secure: config.cookieSecure,\n          sameSite: 'lax',\n          maxAge: 600, // 10分\n          path: '/'\n        }\n      )\n      \n      response.cookies.set(\n        getCookieName(config.cookiePrefix!, 'state'),\n        state,\n        {\n          httpOnly: true,\n          secure: config.cookieSecure,\n          sameSite: 'lax',\n          maxAge: 600, // 10分\n          path: '/'\n        }\n      )\n      \n      response.cookies.set(\n        getCookieName(config.cookiePrefix!, 'callback_url'),\n        callbackUrl,\n        {\n          httpOnly: true,\n          secure: config.cookieSecure,\n          sameSite: 'lax',\n          maxAge: 600, // 10分\n          path: '/'\n        }\n      )\n      \n      return response\n    } catch (error) {\n      console.error('Login handler error:', error)\n      return NextResponse.json(\n        { error: 'Internal server error' },\n        { status: 500 }\n      )\n    }\n  }\n}","import 'server-only'\nimport type { AuthConfig } from '../shared/types'\nimport type { DiscoveryDocument } from './discovery'\n\nlet globalConfig: AuthConfig | null = null\nlet discoveryConfig: DiscoveryDocument | null = null\n\nexport function setAuthConfig(config: AuthConfig): void {\n  // デフォルト値の設定\n  globalConfig = {\n    scopes: ['openid', 'profile', 'email'],\n    redirectUri: '/api/auth/callback',\n    loginPath: '/api/auth/login',\n    callbackPath: '/api/auth/callback',\n    logoutPath: '/api/auth/logout',\n    cookiePrefix: 'noraneko-auth',\n    cookieSecure: process.env.NODE_ENV === 'production',\n    debug: process.env.NODE_ENV === 'development',\n    autoRefresh: {\n      enabled: true,\n      refreshThreshold: 5 * 60 * 1000,  // 5分前\n      maxRetries: 3,\n      retryInterval: 5 * 1000,          // 5秒間隔\n      ...(config.autoRefresh || {})\n    },\n    ...config\n  }\n  \n  // ビルド時Discoveryの結果を取得\n  const discoveryJson = process.env.NORANEKO_DISCOVERY_CONFIG\n  if (!discoveryJson) {\n    throw new Error(\n      'NORANEKO_DISCOVERY_CONFIG environment variable not found. ' +\n      'Make sure to add the discovery configuration to your next.config.js. ' +\n      'See: https://github.com/noraneko-id/nextjs#build-time-discovery'\n    )\n  }\n  \n  try {\n    discoveryConfig = JSON.parse(discoveryJson)\n    \n    // 基本的な検証\n    if (!discoveryConfig || !discoveryConfig.authorization_endpoint || !discoveryConfig.token_endpoint) {\n      throw new Error('Invalid discovery configuration embedded at build time')\n    }\n    \n    if (config.debug) {\n      console.log('Using build-time OIDC discovery configuration:', {\n        authorization_endpoint: discoveryConfig.authorization_endpoint,\n        token_endpoint: discoveryConfig.token_endpoint,\n        userinfo_endpoint: discoveryConfig.userinfo_endpoint,\n      })\n    }\n  } catch (error) {\n    throw new Error(`Failed to parse discovery configuration: ${error instanceof Error ? error.message : 'Unknown error'}`)\n  }\n}\n\n// 環境変数から自動初期化\nfunction initializeFromEnv(): AuthConfig {\n  const issuer = process.env.NORANEKO_ISSUER\n  const clientId = process.env.NORANEKO_CLIENT_ID\n  \n  if (!issuer || !clientId) {\n    throw new Error('NORANEKO_ISSUER and NORANEKO_CLIENT_ID environment variables are required')\n  }\n  \n  return {\n    issuer,\n    clientId,\n    clientSecret: process.env.NORANEKO_CLIENT_SECRET,\n    scopes: ['openid', 'profile', 'email'],\n    redirectUri: '/api/auth/callback',\n    loginPath: '/api/auth/login',\n    callbackPath: '/api/auth/callback',\n    logoutPath: '/api/auth/logout',\n    cookiePrefix: 'noraneko-auth',\n    cookieSecure: process.env.NODE_ENV === 'production',\n    debug: process.env.NODE_ENV === 'development',\n    autoRefresh: {\n      enabled: true,\n      refreshThreshold: 5 * 60 * 1000,  // 5分前\n      maxRetries: 3,\n      retryInterval: 5 * 1000           // 5秒間隔\n    }\n  }\n}\n\nexport function getAuthConfig(): AuthConfig {\n  if (!globalConfig) {\n    // 環境変数から自動初期化を試行\n    try {\n      globalConfig = initializeFromEnv()\n    } catch (error) {\n      throw new Error('Auth config not initialized. Call createAuth() first or set environment variables.')\n    }\n  }\n  return globalConfig\n}\n\nexport function createAuth(config: AuthConfig): void {\n  setAuthConfig(config)\n}\n\nexport function getDiscoveryConfig(): DiscoveryDocument | null {\n  return discoveryConfig\n}","import crypto from 'crypto'\n\n// PKCE (Proof Key for Code Exchange) utilities\nexport function generateCodeVerifier(): string {\n  return crypto.randomBytes(32).toString('base64url')\n}\n\nexport function generateCodeChallenge(verifier: string): string {\n  return crypto.createHash('sha256').update(verifier).digest('base64url')\n}\n\nexport function generateState(): string {\n  return crypto.randomBytes(16).toString('base64url')\n}\n\n// URL utilities\nexport function buildAuthUrl(config: {\n  issuer: string\n  clientId: string\n  redirectUri: string\n  scopes: string[]\n  state: string\n  codeChallenge: string\n  authorizationEndpoint: string\n}): string {\n  const params = new URLSearchParams({\n    response_type: 'code',\n    client_id: config.clientId,\n    redirect_uri: config.redirectUri,\n    scope: config.scopes.join(' '),\n    state: config.state,\n    code_challenge: config.codeChallenge,\n    code_challenge_method: 'S256'\n  })\n  \n  return `${config.authorizationEndpoint}?${params.toString()}`\n}\n\n// Token utilities\nexport function isTokenExpired(expiresAt: number): boolean {\n  return Date.now() >= expiresAt\n}\n\nexport function isTokenExpiringSoon(expiresAt: number, bufferMs = 60000): boolean {\n  return Date.now() >= (expiresAt - bufferMs)\n}\n\n// Cookie utilities\nexport function getCookieName(prefix: string, name: string): string {\n  return `${prefix}.${name}`\n}\n\nexport function parseCookieValue<T>(value: string | undefined): T | null {\n  if (!value) return null\n  try {\n    return JSON.parse(value)\n  } catch {\n    return null\n  }\n}\n\nexport function serializeCookieValue<T>(value: T): string {\n  return JSON.stringify(value)\n}","import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthConfig } from '../../server/config'\nimport { exchangeCodeForTokens, saveSession } from '../../server/auth'\nimport { \n  getCookieName,\n  parseCookieValue\n} from '../../shared/utils'\nimport { OAuthError } from '../../shared/errors'\n\nexport function createCallbackHandler() {\n  return async function callbackHandler(request: NextRequest) {\n    try {\n      const config = getAuthConfig()\n      const { searchParams } = new URL(request.url)\n      \n      // OAuth2パラメータ取得\n      const code = searchParams.get('code')\n      const state = searchParams.get('state')\n      const error = searchParams.get('error')\n      const errorDescription = searchParams.get('error_description')\n      \n      // エラーチェック\n      if (error) {\n        throw new OAuthError(error, errorDescription || undefined)\n      }\n      \n      if (!code || !state) {\n        throw new Error('Missing required OAuth parameters')\n      }\n      \n      // Cookieから保存した情報を取得\n      const codeVerifier = request.cookies.get(getCookieName(config.cookiePrefix!, 'code_verifier'))?.value\n      const savedState = request.cookies.get(getCookieName(config.cookiePrefix!, 'state'))?.value\n      const callbackUrl = request.cookies.get(getCookieName(config.cookiePrefix!, 'callback_url'))?.value || '/'\n      \n      if (!codeVerifier || !savedState) {\n        throw new Error('Missing PKCE parameters')\n      }\n      \n      // State検証\n      if (state !== savedState) {\n        throw new Error('Invalid state parameter')\n      }\n      \n      // 認可コードをトークンに交換\n      const session = await exchangeCodeForTokens(\n        code,\n        codeVerifier,\n        new URL(config.redirectUri!, request.url).toString()\n      )\n      \n      // セッション保存\n      await saveSession(session)\n      \n      // 一時的なCookieをクリア\n      const response = NextResponse.redirect(new URL(callbackUrl, request.url))\n      \n      response.cookies.delete(getCookieName(config.cookiePrefix!, 'code_verifier'))\n      response.cookies.delete(getCookieName(config.cookiePrefix!, 'state'))\n      response.cookies.delete(getCookieName(config.cookiePrefix!, 'callback_url'))\n      \n      return response\n    } catch (error) {\n      console.error('Callback handler error:', error)\n      \n      // エラーページにリダイレクト\n      const errorUrl = new URL('/login', request.url)\n      errorUrl.searchParams.set('error', 'callback_error')\n      \n      if (error instanceof OAuthError) {\n        errorUrl.searchParams.set('error_description', error.message)\n      }\n      \n      return NextResponse.redirect(errorUrl)\n    }\n  }\n}","import 'server-only'\nimport { cookies } from 'next/headers'\nimport type { Session, User, TokenResponse, UserInfoResponse } from '../shared/types'\nimport { getAuthConfig, getDiscoveryConfig } from './config'\nimport { \n  AuthenticationRequiredError, \n  TokenExpiredError, \n  InvalidTokenError,\n  OAuthError \n} from '../shared/errors'\nimport { \n  getCookieName, \n  parseCookieValue, \n  serializeCookieValue,\n  isTokenExpired,\n  isTokenExpiringSoon\n} from '../shared/utils'\n\n// NextAuth v5風の統一インターフェース\nexport async function auth(): Promise<Session | null> {\n  try {\n    const config = getAuthConfig()\n    const session = await getSession()\n    \n    if (!session) {\n      return null\n    }\n    \n    // 自動リフレッシュが無効の場合は基本チェックのみ\n    if (!config.autoRefresh?.enabled) {\n      if (isTokenExpired(session.expiresAt)) {\n        await clearSession()\n        return null\n      }\n      return session\n    }\n    \n    // トークンの有効期限チェック（期限切れ）\n    if (isTokenExpired(session.expiresAt)) {\n      if (session.refreshToken) {\n        // リフレッシュトークンでセッション更新を試行（リトライ付き）\n        const refreshed = await refreshSessionWithRetry(\n          session.refreshToken, \n          config.autoRefresh.maxRetries || 3,\n          config.autoRefresh.retryInterval || 5000\n        )\n        if (refreshed) {\n          await saveSession(refreshed)\n          return refreshed\n        }\n      }\n      // リフレッシュ失敗またはリフレッシュトークンがない場合はセッションクリア\n      await clearSession()\n      return null\n    }\n    \n    // 期限が近い場合はバックグラウンドでリフレッシュ\n    const threshold = config.autoRefresh.refreshThreshold || 5 * 60 * 1000\n    if (session.refreshToken && isTokenExpiringSoon(session.expiresAt, threshold)) {\n      // 非同期でリフレッシュ（await しない）\n      refreshSessionWithRetry(\n        session.refreshToken,\n        config.autoRefresh.maxRetries || 3,\n        config.autoRefresh.retryInterval || 5000\n      )\n        .then(refreshed => refreshed && saveSession(refreshed))\n        .catch((error) => {\n          if (config.debug) {\n            console.error('Background token refresh failed:', error)\n          }\n        })\n    }\n    \n    return session\n  } catch (error) {\n    if (getAuthConfig().debug) {\n      console.error('Auth error:', error)\n    }\n    return null\n  }\n}\n\n// 認証必須のヘルパー（NextAuth v5風）\nexport async function requireAuth(): Promise<User> {\n  const session = await auth()\n  if (!session) {\n    throw new AuthenticationRequiredError()\n  }\n  return session.user\n}\n\n// セッション取得（内部関数）\nasync function getSession(): Promise<Session | null> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  const sessionCookie = cookieStore.get(getCookieName(config.cookiePrefix!, 'token'))\n  \n  return parseCookieValue<Session>(sessionCookie?.value)\n}\n\n// セッション保存\nexport async function saveSession(session: Session): Promise<void> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  \n  cookieStore.set(getCookieName(config.cookiePrefix!, 'token'), serializeCookieValue(session), {\n    httpOnly: true,\n    secure: config.cookieSecure,\n    sameSite: 'lax',\n    maxAge: Math.floor((session.expiresAt - Date.now()) / 1000),\n    path: '/'\n  })\n}\n\n// セッションクリア\nexport async function clearSession(): Promise<void> {\n  const config = getAuthConfig()\n  const cookieStore = await cookies()\n  \n  cookieStore.delete(getCookieName(config.cookiePrefix!, 'token'))\n}\n\n// OAuth2トークン交換\nexport async function exchangeCodeForTokens(\n  code: string,\n  codeVerifier: string,\n  redirectUri: string\n): Promise<Session> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery) {\n    throw new Error('Discovery configuration not available')\n  }\n  \n  const tokenResponse = await fetch(discovery.token_endpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      client_id: config.clientId,\n      code,\n      redirect_uri: redirectUri,\n      code_verifier: codeVerifier\n    })\n  })\n  \n  if (!tokenResponse.ok) {\n    const error = await tokenResponse.json().catch(() => ({}))\n    throw new OAuthError(error.error || 'token_exchange_failed', error.error_description)\n  }\n  \n  const tokens: TokenResponse = await tokenResponse.json()\n  \n  // ユーザー情報取得\n  const userInfo = await fetchUserInfo(tokens.access_token)\n  \n  // セッション作成\n  const session: Session = {\n    user: {\n      id: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      image: userInfo.picture\n    },\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token,\n    expiresAt: Date.now() + (tokens.expires_in * 1000),\n    scope: tokens.scope\n  }\n  \n  return session\n}\n\n// リフレッシュトークンでセッション更新（リトライ機能付き）\nasync function refreshSessionWithRetry(\n  refreshToken: string, \n  maxRetries: number = 3, \n  retryInterval: number = 5000\n): Promise<Session | null> {\n  let lastError: Error | null = null\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const session = await refreshSession(refreshToken)\n      if (session) {\n        if (getAuthConfig().debug && attempt > 1) {\n          console.log(`Token refresh succeeded on attempt ${attempt}`)\n        }\n        return session\n      }\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('Unknown error')\n      \n      if (getAuthConfig().debug) {\n        console.warn(`Token refresh attempt ${attempt}/${maxRetries} failed:`, lastError.message)\n      }\n      \n      // 最後の試行でなければ待機\n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, retryInterval))\n      }\n    }\n  }\n  \n  if (getAuthConfig().debug) {\n    console.error(`Token refresh failed after ${maxRetries} attempts. Last error:`, lastError?.message)\n  }\n  \n  return null\n}\n\n// リフレッシュトークンでセッション更新（基本実装）\nasync function refreshSession(refreshToken: string): Promise<Session | null> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery) {\n    throw new Error('Discovery configuration not available')\n  }\n  \n  const tokenResponse = await fetch(discovery.token_endpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      client_id: config.clientId,\n      refresh_token: refreshToken\n    })\n  })\n  \n  if (!tokenResponse.ok) {\n    const errorData = await tokenResponse.json().catch(() => ({}))\n    throw new TokenExpiredError(`Failed to refresh token: ${errorData.error || tokenResponse.statusText}`)\n  }\n  \n  const tokens: TokenResponse = await tokenResponse.json()\n  const userInfo = await fetchUserInfo(tokens.access_token)\n  \n  return {\n    user: {\n      id: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      image: userInfo.picture\n    },\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token || refreshToken, // 新しいリフレッシュトークンがなければ既存を使用\n    expiresAt: Date.now() + (tokens.expires_in * 1000),\n    scope: tokens.scope\n  }\n}\n\n// ユーザー情報取得\nasync function fetchUserInfo(accessToken: string): Promise<UserInfoResponse> {\n  const config = getAuthConfig()\n  const discovery = getDiscoveryConfig()\n  if (!discovery || !discovery.userinfo_endpoint) {\n    throw new Error('Discovery configuration or userinfo endpoint not available')\n  }\n  \n  const userResponse = await fetch(discovery.userinfo_endpoint, {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`\n    }\n  })\n  \n  if (!userResponse.ok) {\n    throw new InvalidTokenError('Failed to fetch user info')\n  }\n  \n  return userResponse.json()\n}","import type { AuthError } from './types'\n\nexport class NoranekoAuthError extends Error implements AuthError {\n  readonly type = 'AuthError' as const\n  \n  constructor(\n    public code: string,\n    message: string,\n    public cause?: Error\n  ) {\n    super(message)\n    this.name = 'NoranekoAuthError'\n  }\n}\n\nexport class TokenExpiredError extends NoranekoAuthError {\n  constructor(message = 'Token has expired') {\n    super('TOKEN_EXPIRED', message)\n  }\n}\n\nexport class InvalidTokenError extends NoranekoAuthError {\n  constructor(message = 'Invalid token') {\n    super('INVALID_TOKEN', message)\n  }\n}\n\nexport class AuthenticationRequiredError extends NoranekoAuthError {\n  constructor(message = 'Authentication required') {\n    super('AUTHENTICATION_REQUIRED', message)\n  }\n}\n\nexport class OAuthError extends NoranekoAuthError {\n  constructor(\n    public oauthError: string,\n    public oauthErrorDescription?: string\n  ) {\n    super('OAUTH_ERROR', `OAuth error: ${oauthError}${oauthErrorDescription ? ` - ${oauthErrorDescription}` : ''}`)\n  }\n}","import { NextRequest, NextResponse } from 'next/server'\nimport { getAuthConfig, getDiscoveryConfig } from '../../server/config'\nimport { clearSession, auth } from '../../server/auth'\n\nexport function createLogoutHandler() {\n  return async function logoutHandler(request: NextRequest) {\n    try {\n      const config = getAuthConfig()\n      const { searchParams } = new URL(request.url)\n      const callbackUrl = searchParams.get('callbackUrl') || '/'\n      \n      // 現在のセッション取得（ログアウトURL生成のため）\n      const session = await auth()\n      \n      // セッション削除\n      await clearSession()\n      \n      // OAuth2 End Session Endpoint対応\n      if (session?.accessToken) {\n        const discovery = getDiscoveryConfig()\n        \n        // トークン取り消し（もしrevocation_endpointがあれば）\n        if (discovery?.revocation_endpoint) {\n          try {\n            await fetch(discovery.revocation_endpoint, {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n              },\n              body: new URLSearchParams({\n                token: session.accessToken,\n                client_id: config.clientId,\n                client_secret: config.clientSecret || '',\n              }),\n            })\n          } catch (error) {\n            // エラーは無視（ログアウトは続行）\n            if (config.debug) {\n              console.error('Token revocation failed:', error)\n            }\n          }\n        }\n        \n        // OP（noraneko-id）のログアウトエンドポイントにリダイレクト（もしあれば）\n        const endSessionEndpoint = discovery?.end_session_endpoint\n        if (endSessionEndpoint) {\n          const logoutUrl = new URL(endSessionEndpoint)\n          logoutUrl.searchParams.set('post_logout_redirect_uri', new URL(callbackUrl, request.url).toString())\n          if (session.accessToken) {\n            logoutUrl.searchParams.set('id_token_hint', session.accessToken)\n          }\n          return NextResponse.redirect(logoutUrl)\n        }\n      }\n      \n      // セッションがない、またはend_session_endpointがない場合は直接callbackUrlにリダイレクト\n      return NextResponse.redirect(new URL(callbackUrl, request.url))\n    } catch (error) {\n      console.error('Logout handler error:', error)\n      \n      // エラーが発生してもログアウトは継続\n      const { searchParams } = new URL(request.url)\n      const callbackUrl = searchParams.get('callbackUrl') || '/'\n      \n      return NextResponse.redirect(new URL(callbackUrl, request.url))\n    }\n  }\n}","import { NextRequest, NextResponse } from 'next/server'\nimport { auth } from '../../server/auth'\n\n/**\n * GET /api/auth/token - 現在のトークン状態取得\n * RFC 6749準拠: トークン関連の操作を /token エンドポイントで実行\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await auth()\n    \n    if (!session) {\n      return NextResponse.json(null, { status: 200 })\n    }\n    \n    // RFC準拠のレスポンス形式\n    // セキュリティのためアクセストークンは除外\n    const tokenResponse = {\n      user: session.user,\n      expires_at: Math.floor(session.expiresAt / 1000), // Unix timestamp (seconds)\n      scope: session.scope\n    }\n    \n    return NextResponse.json(tokenResponse, { status: 200 })\n  } catch (error) {\n    console.error('Token handler error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * POST /api/auth/token - トークンリフレッシュ\n * RFC 6749 Section 6: Refreshing an Access Token\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // auth()を呼ぶことで自動的にトークンリフレッシュが行われる\n    const session = await auth()\n    \n    if (!session) {\n      return NextResponse.json(\n        { \n          error: 'invalid_token',\n          error_description: 'No valid session found'\n        }, \n        { status: 401 }\n      )\n    }\n    \n    // RFC準拠のレスポンス形式\n    const tokenResponse = {\n      user: session.user,\n      expires_at: Math.floor(session.expiresAt / 1000), // Unix timestamp (seconds)\n      scope: session.scope\n    }\n    \n    return NextResponse.json(tokenResponse, { status: 200 })\n  } catch (error) {\n    console.error('Token refresh error:', error)\n    return NextResponse.json(\n      { \n        error: 'server_error',\n        error_description: 'Internal server error during token refresh'\n      },\n      { status: 500 }\n    )\n  }\n}","import { NextRequest } from 'next/server'\nimport { createLoginHandler } from './handlers/login'\nimport { createCallbackHandler } from './handlers/callback'\nimport { createLogoutHandler } from './handlers/logout'\nimport { GET as tokenHandler, POST as tokenRefreshHandler } from './handlers/token'\n\n/**\n * NextAuth風の統一ハンドラー\n * \n * @example\n * ```typescript\n * // app/api/auth/[...noraneko]/route.ts\n * import { handlers } from \"@noranekoid/nextjs/api\"\n * export const { GET, POST } = handlers\n * ```\n */\nexport const handlers = {\n  GET: async (request: NextRequest) => {\n    const { pathname } = new URL(request.url)\n    const segments = pathname.split('/').filter(Boolean)\n    const action = segments[segments.length - 1] // 最後のセグメント\n\n    switch (action) {\n      case 'login':\n        return createLoginHandler()(request)\n      \n      case 'callback':\n        return createCallbackHandler()(request)\n      \n      case 'logout':\n        return createLogoutHandler()(request)\n      \n      case 'token':\n        // RFC準拠: 推奨エンドポイント\n        return tokenHandler(request)\n      \n      default:\n        // デフォルトはRFC準拠のtokenエンドポイント\n        return tokenHandler(request)\n    }\n  },\n\n  POST: async (request: NextRequest) => {\n    const { pathname } = new URL(request.url)\n    const segments = pathname.split('/').filter(Boolean)\n    const action = segments[segments.length - 1]\n\n    switch (action) {\n      case 'token':\n        // RFC準拠: 推奨エンドポイント\n        return tokenRefreshHandler(request)\n      \n      default:\n        return new Response('Method not allowed', { status: 405 })\n    }\n  }\n}\n\n/**\n * 個別ハンドラーの作成関数\n */\nexport { createLoginHandler, createCallbackHandler, createLogoutHandler }","import { NextRequest } from 'next/server'\nimport { createLoginHandler } from './handlers/login'\nimport { createCallbackHandler } from './handlers/callback'\nimport { createLogoutHandler } from './handlers/logout'\nimport { GET as tokenHandler, POST as tokenRefreshHandler } from './handlers/token'\n\ninterface HandlersConfig {\n  /**\n   * カスタムパスマッピング\n   * デフォルト: { login: 'login', callback: 'callback', logout: 'logout', token: 'token' }\n   */\n  paths?: {\n    login?: string\n    callback?: string\n    logout?: string\n    token?: string    // RFC準拠\n  }\n  \n  /**\n   * デフォルトアクション（パスが一致しない場合）\n   * デフォルト: 'token' (RFC準拠)\n   */\n  defaultAction?: 'token' | 'login' | 'callback' | 'logout'\n}\n\n/**\n * カスタマイズ可能なハンドラーを作成\n * \n * @param config ハンドラー設定\n * @returns NextAuth風の統一ハンドラー\n * \n * @example\n * ```typescript\n * // app/api/auth/[...noraneko]/route.ts\n * import { createHandlers } from \"@noranekoid/nextjs/api\"\n * \n * export const { GET, POST } = createHandlers({\n *   paths: {\n *     login: 'signin',      // /api/auth/signin\n *     logout: 'signout',    // /api/auth/signout\n *     callback: 'callback', // /api/auth/callback\n *     token: 'token'        // /api/auth/token\n *   }\n * })\n * ```\n */\nexport function createHandlers(config: HandlersConfig = {}) {\n  const {\n    paths = {\n      login: 'login',\n      callback: 'callback', \n      logout: 'logout',\n      token: 'token'       // RFC準拠: デフォルト\n    },\n    defaultAction = 'token'  // RFC準拠: デフォルト\n  } = config\n\n  // デフォルト値をマージ\n  const finalPaths = {\n    login: 'login',\n    callback: 'callback',\n    logout: 'logout', \n    token: 'token',      // RFC準拠\n    ...paths\n  }\n\n  return {\n    GET: async (request: NextRequest) => {\n      const { pathname } = new URL(request.url)\n      const segments = pathname.split('/').filter(Boolean)\n      const action = segments[segments.length - 1] // 最後のセグメント\n\n      // パスマッピングから対応するアクションを特定\n      let targetAction = defaultAction\n      for (const [key, value] of Object.entries(finalPaths)) {\n        if (action === value) {\n          targetAction = key as keyof typeof finalPaths\n          break\n        }\n      }\n\n      switch (targetAction) {\n        case 'login':\n          return createLoginHandler()(request)\n        \n        case 'callback':\n          return createCallbackHandler()(request)\n        \n        case 'logout':\n          return createLogoutHandler()(request)\n        \n        case 'token':\n          return tokenHandler(request)\n        \n        default:\n          return tokenHandler(request)\n      }\n    },\n\n    POST: async (request: NextRequest) => {\n      const { pathname } = new URL(request.url)\n      const segments = pathname.split('/').filter(Boolean)\n      const action = segments[segments.length - 1]\n\n      // パスマッピングから対応するアクションを特定\n      let targetAction = defaultAction\n      for (const [key, value] of Object.entries(finalPaths)) {\n        if (action === value) {\n          targetAction = key as keyof typeof finalPaths\n          break\n        }\n      }\n\n      switch (targetAction) {\n        case 'token':\n          return tokenRefreshHandler(request)\n        \n        default:\n          return new Response('Method not allowed', { status: 405 })\n      }\n    }\n  }\n}"],"mappings":"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","names":["NextResponse","NextResponse","NextResponse","NextResponse","NextResponse","NextResponse"]}