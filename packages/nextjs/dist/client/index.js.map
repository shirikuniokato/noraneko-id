{"version":3,"sources":["../../src/client/index.ts","../../src/client/hooks.ts","../../src/client/providers.tsx","../../src/client/useAuthCallback.ts"],"sourcesContent":["'use client'\nimport 'client-only'\n\n// React hooks\nexport { useSession, useAuth, useUser, useAuthStatus, useAuthCallback } from './hooks'\n\n// Context providers\nexport { SessionProvider } from './providers'\n\n// 型定義（client側で必要なもののみ）\nexport type { \n  Session, \n  User, \n  AuthStatus, \n  CallbackStatus, \n  CallbackError, \n  CallbackState, \n  CallbackParams \n} from '../shared/types'","'use client'\nimport 'client-only'\nimport { useSessionContext } from './providers'\nimport type { Session, User } from '../shared/types'\n\n// useAuthCallbackの再エクスポート\nexport { useAuthCallback } from './useAuthCallback'\n\n// NextAuth風のuseSession\nexport function useSession() {\n  const { data, status, update } = useSessionContext()\n  \n  return {\n    data,\n    status,\n    update\n  }\n}\n\n// noraneko-id独自のuseAuth\nexport function useAuth() {\n  const { data: session, status, update } = useSessionContext()\n  \n  const login = (redirectTo?: string) => {\n    const url = new URL('/api/auth/login', window.location.origin)\n    if (redirectTo) {\n      url.searchParams.set('callbackUrl', redirectTo)\n    }\n    window.location.href = url.toString()\n  }\n  \n  const logout = (redirectTo?: string) => {\n    const url = new URL('/api/auth/logout', window.location.origin)\n    if (redirectTo) {\n      url.searchParams.set('callbackUrl', redirectTo)\n    }\n    window.location.href = url.toString()\n  }\n  \n  return {\n    session,\n    user: session?.user || null,\n    status,\n    isLoading: status === 'loading',\n    isAuthenticated: status === 'authenticated',\n    login,\n    logout,\n    refresh: update\n  }\n}\n\n// ユーザー情報のみを取得するhook\nexport function useUser(): User | null {\n  const { data: session } = useSessionContext()\n  return session?.user || null\n}\n\n// 認証状態のみを取得するhook  \nexport function useAuthStatus() {\n  const { status } = useSessionContext()\n  return status\n}","'use client'\nimport 'client-only'\nimport React, { createContext, useContext, useEffect, useState, type ReactNode } from 'react'\nimport type { Session, AuthStatus } from '../shared/types'\n\ninterface SessionContextValue {\n  data: Session | null\n  status: AuthStatus\n  update: () => Promise<void>\n}\n\nconst SessionContext = createContext<SessionContextValue | undefined>(undefined)\n\ninterface SessionProviderProps {\n  children: ReactNode\n  session?: Session | null\n}\n\nexport function SessionProvider({ children, session: initialSession }: SessionProviderProps) {\n  const [session, setSession] = useState<Session | null>(initialSession || null)\n  const [status, setStatus] = useState<AuthStatus>(\n    initialSession ? 'authenticated' : 'loading'\n  )\n\n  const updateSession = async () => {\n    try {\n      setStatus('loading')\n      const response = await fetch('/api/auth/token')\n      \n      if (response.ok) {\n        const data = await response.json()\n        setSession(data)\n        setStatus(data ? 'authenticated' : 'unauthenticated')\n      } else {\n        setSession(null)\n        setStatus('unauthenticated')\n      }\n    } catch (error) {\n      console.error('Failed to update token:', error)\n      setSession(null)\n      setStatus('unauthenticated')\n    }\n  }\n\n  // 初期化時とフォーカス時にトークン更新\n  useEffect(() => {\n    if (!initialSession) {\n      updateSession()\n    }\n\n    const handleFocus = () => updateSession()\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible') {\n        updateSession()\n      }\n    }\n\n    window.addEventListener('focus', handleFocus)\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n\n    return () => {\n      window.removeEventListener('focus', handleFocus)\n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n    }\n  }, [initialSession])\n\n  // トークン期限チェック\n  useEffect(() => {\n    if (!session || status !== 'authenticated') return\n\n    const checkExpiration = () => {\n      if (Date.now() >= session.expiresAt) {\n        updateSession()\n      }\n    }\n\n    const timeUntilExpiry = session.expiresAt - Date.now()\n    const checkInterval = Math.min(timeUntilExpiry / 2, 60000) // 最大1分間隔\n\n    const interval = setInterval(checkExpiration, checkInterval)\n    return () => clearInterval(interval)\n  }, [session, status])\n\n  const value: SessionContextValue = {\n    data: session,\n    status,\n    update: updateSession\n  }\n\n  return (\n    <SessionContext.Provider value={value}>\n      {children}\n    </SessionContext.Provider>\n  )\n}\n\nexport function useSessionContext(): SessionContextValue {\n  const context = useContext(SessionContext)\n  if (context === undefined) {\n    throw new Error('useSessionContext must be used within a SessionProvider')\n  }\n  return context\n}","'use client'\nimport 'client-only'\nimport { useEffect, useState } from 'react'\nimport { useRouter, useSearchParams } from 'next/navigation'\nimport type { CallbackState, CallbackParams, CallbackError } from '../shared/types'\n\ninterface UseAuthCallbackOptions {\n  /**\n   * コールバック成功時のリダイレクト先\n   * デフォルト: \"/\"\n   */\n  successRedirect?: string\n  \n  /**\n   * エラー時のリダイレクト先\n   * デフォルト: \"/login\"\n   */\n  errorRedirect?: string\n  \n  /**\n   * 自動リダイレクトを無効にする\n   * デフォルト: false\n   */\n  disableAutoRedirect?: boolean\n  \n  /**\n   * コールバック処理完了時のカスタムハンドラ\n   */\n  onSuccess?: (params: CallbackParams) => void\n  onError?: (error: CallbackError) => void\n}\n\n/**\n * OAuth2コールバック処理専用フック\n * \n * @param options コールバック処理のオプション\n * @returns コールバック状態とユーティリティ関数\n * \n * @example\n * ```tsx\n * // app/auth/callback/page.tsx\n * 'use client'\n * import { useAuthCallback } from '@noranekoid/nextjs/client'\n * \n * export default function CallbackPage() {\n *   const { status, error, isLoading } = useAuthCallback({\n *     successRedirect: '/dashboard',\n *     errorRedirect: '/login?error=callback_failed'\n *   })\n *   \n *   if (isLoading) return <div>認証処理中...</div>\n *   if (error) return <div>エラー: {error.error_description || error.error}</div>\n *   return <div>処理中...</div>\n * }\n * ```\n */\nexport function useAuthCallback(options: UseAuthCallbackOptions = {}): CallbackState {\n  const {\n    successRedirect = '/',\n    errorRedirect = '/login',\n    disableAutoRedirect = false,\n    onSuccess,\n    onError\n  } = options\n\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  \n  const [state, setState] = useState<CallbackState>({\n    status: 'loading',\n    error: null,\n    isLoading: true,\n    isSuccess: false,\n    isError: false\n  })\n\n  useEffect(() => {\n    const processCallback = async () => {\n      try {\n        // URLパラメータを取得\n        const params: CallbackParams = {\n          code: searchParams.get('code') || undefined,\n          state: searchParams.get('state') || undefined,\n          error: searchParams.get('error') || undefined,\n          error_description: searchParams.get('error_description') || undefined,\n          error_uri: searchParams.get('error_uri') || undefined\n        }\n\n        // エラーパラメータがある場合\n        if (params.error) {\n          const callbackError: CallbackError = {\n            error: params.error,\n            error_description: params.error_description,\n            error_uri: params.error_uri\n          }\n\n          setState({\n            status: 'error',\n            error: callbackError,\n            isLoading: false,\n            isSuccess: false,\n            isError: true\n          })\n\n          // カスタムエラーハンドラを呼び出し\n          onError?.(callbackError)\n\n          // 自動リダイレクト\n          if (!disableAutoRedirect) {\n            const errorUrl = new URL(errorRedirect, window.location.origin)\n            errorUrl.searchParams.set('callback_error', params.error)\n            if (params.error_description) {\n              errorUrl.searchParams.set('error_description', params.error_description)\n            }\n            router.push(errorUrl.toString())\n          }\n          return\n        }\n\n        // 認可コードがない場合\n        if (!params.code) {\n          const callbackError: CallbackError = {\n            error: 'invalid_request',\n            error_description: 'Authorization code not found in callback parameters'\n          }\n\n          setState({\n            status: 'error',\n            error: callbackError,\n            isLoading: false,\n            isSuccess: false,\n            isError: true\n          })\n\n          onError?.(callbackError)\n\n          if (!disableAutoRedirect) {\n            router.push(`${errorRedirect}?error=no_code`)\n          }\n          return\n        }\n\n        // コールバック処理をサーバーに送信\n        const callbackUrl = new URL('/api/auth/callback', window.location.origin)\n        callbackUrl.search = window.location.search // 全パラメータを転送\n\n        const response = await fetch(callbackUrl.toString(), {\n          method: 'GET',\n          credentials: 'include'\n        })\n\n        if (!response.ok) {\n          // サーバーエラーの処理\n          let errorMessage = 'Authentication failed'\n          try {\n            const errorData = await response.json()\n            errorMessage = errorData.error_description || errorData.error || errorMessage\n          } catch {\n            errorMessage = `HTTP ${response.status}: ${response.statusText}`\n          }\n\n          const callbackError: CallbackError = {\n            error: 'server_error',\n            error_description: errorMessage\n          }\n\n          setState({\n            status: 'error',\n            error: callbackError,\n            isLoading: false,\n            isSuccess: false,\n            isError: true\n          })\n\n          onError?.(callbackError)\n\n          if (!disableAutoRedirect) {\n            router.push(`${errorRedirect}?error=server_error`)\n          }\n          return\n        }\n\n        // 成功時の処理\n        setState({\n          status: 'success',\n          error: null,\n          isLoading: false,\n          isSuccess: true,\n          isError: false\n        })\n\n        onSuccess?.(params)\n\n        // 成功時のリダイレクト\n        if (!disableAutoRedirect) {\n          // 元々のリダイレクト先を取得（state パラメータや callbackUrl パラメータから）\n          const originalRedirect = searchParams.get('callbackUrl') || successRedirect\n          router.push(originalRedirect)\n        }\n\n      } catch (error) {\n        // ネットワークエラーなどの処理\n        const callbackError: CallbackError = {\n          error: 'network_error',\n          error_description: error instanceof Error ? error.message : 'Network error occurred'\n        }\n\n        setState({\n          status: 'error',\n          error: callbackError,\n          isLoading: false,\n          isSuccess: false,\n          isError: true\n        })\n\n        onError?.(callbackError)\n\n        if (!disableAutoRedirect) {\n          router.push(`${errorRedirect}?error=network_error`)\n        }\n      }\n    }\n\n    processCallback()\n  }, [searchParams, router, successRedirect, errorRedirect, disableAutoRedirect, onSuccess, onError])\n\n  return state\n}"],"mappings":";;;AACA,OAAO;;;ACAP,OAAO;;;ACAP,OAAO;AACP,OAAO,SAAS,eAAe,YAAY,WAAW,gBAAgC;AAStF,IAAM,iBAAiB,cAA+C,MAAS;AAOxE,SAAS,gBAAgB,EAAE,UAAU,SAAS,eAAe,GAAyB;AAC3F,QAAM,CAAC,SAAS,UAAU,IAAI,SAAyB,kBAAkB,IAAI;AAC7E,QAAM,CAAC,QAAQ,SAAS,IAAI;AAAA,IAC1B,iBAAiB,kBAAkB;AAAA,EACrC;AAEA,QAAM,gBAAgB,YAAY;AAChC,QAAI;AACF,gBAAU,SAAS;AACnB,YAAM,WAAW,MAAM,MAAM,iBAAiB;AAE9C,UAAI,SAAS,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,KAAK;AACjC,mBAAW,IAAI;AACf,kBAAU,OAAO,kBAAkB,iBAAiB;AAAA,MACtD,OAAO;AACL,mBAAW,IAAI;AACf,kBAAU,iBAAiB;AAAA,MAC7B;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,iBAAW,IAAI;AACf,gBAAU,iBAAiB;AAAA,IAC7B;AAAA,EACF;AAGA,YAAU,MAAM;AACd,QAAI,CAAC,gBAAgB;AACnB,oBAAc;AAAA,IAChB;AAEA,UAAM,cAAc,MAAM,cAAc;AACxC,UAAM,yBAAyB,MAAM;AACnC,UAAI,SAAS,oBAAoB,WAAW;AAC1C,sBAAc;AAAA,MAChB;AAAA,IACF;AAEA,WAAO,iBAAiB,SAAS,WAAW;AAC5C,aAAS,iBAAiB,oBAAoB,sBAAsB;AAEpE,WAAO,MAAM;AACX,aAAO,oBAAoB,SAAS,WAAW;AAC/C,eAAS,oBAAoB,oBAAoB,sBAAsB;AAAA,IACzE;AAAA,EACF,GAAG,CAAC,cAAc,CAAC;AAGnB,YAAU,MAAM;AACd,QAAI,CAAC,WAAW,WAAW,gBAAiB;AAE5C,UAAM,kBAAkB,MAAM;AAC5B,UAAI,KAAK,IAAI,KAAK,QAAQ,WAAW;AACnC,sBAAc;AAAA,MAChB;AAAA,IACF;AAEA,UAAM,kBAAkB,QAAQ,YAAY,KAAK,IAAI;AACrD,UAAM,gBAAgB,KAAK,IAAI,kBAAkB,GAAG,GAAK;AAEzD,UAAM,WAAW,YAAY,iBAAiB,aAAa;AAC3D,WAAO,MAAM,cAAc,QAAQ;AAAA,EACrC,GAAG,CAAC,SAAS,MAAM,CAAC;AAEpB,QAAM,QAA6B;AAAA,IACjC,MAAM;AAAA,IACN;AAAA,IACA,QAAQ;AAAA,EACV;AAEA,SACE,oCAAC,eAAe,UAAf,EAAwB,SACtB,QACH;AAEJ;AAEO,SAAS,oBAAyC;AACvD,QAAM,UAAU,WAAW,cAAc;AACzC,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC3E;AACA,SAAO;AACT;;;ACrGA,OAAO;AACP,SAAS,aAAAA,YAAW,YAAAC,iBAAgB;AACpC,SAAS,WAAW,uBAAuB;AAqDpC,SAAS,gBAAgB,UAAkC,CAAC,GAAkB;AACnF,QAAM;AAAA,IACJ,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,sBAAsB;AAAA,IACtB;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,QAAM,SAAS,UAAU;AACzB,QAAM,eAAe,gBAAgB;AAErC,QAAM,CAAC,OAAO,QAAQ,IAAIA,UAAwB;AAAA,IAChD,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,WAAW;AAAA,IACX,WAAW;AAAA,IACX,SAAS;AAAA,EACX,CAAC;AAED,EAAAD,WAAU,MAAM;AACd,UAAM,kBAAkB,YAAY;AAClC,UAAI;AAEF,cAAM,SAAyB;AAAA,UAC7B,MAAM,aAAa,IAAI,MAAM,KAAK;AAAA,UAClC,OAAO,aAAa,IAAI,OAAO,KAAK;AAAA,UACpC,OAAO,aAAa,IAAI,OAAO,KAAK;AAAA,UACpC,mBAAmB,aAAa,IAAI,mBAAmB,KAAK;AAAA,UAC5D,WAAW,aAAa,IAAI,WAAW,KAAK;AAAA,QAC9C;AAGA,YAAI,OAAO,OAAO;AAChB,gBAAM,gBAA+B;AAAA,YACnC,OAAO,OAAO;AAAA,YACd,mBAAmB,OAAO;AAAA,YAC1B,WAAW,OAAO;AAAA,UACpB;AAEA,mBAAS;AAAA,YACP,QAAQ;AAAA,YACR,OAAO;AAAA,YACP,WAAW;AAAA,YACX,WAAW;AAAA,YACX,SAAS;AAAA,UACX,CAAC;AAGD,oBAAU,aAAa;AAGvB,cAAI,CAAC,qBAAqB;AACxB,kBAAM,WAAW,IAAI,IAAI,eAAe,OAAO,SAAS,MAAM;AAC9D,qBAAS,aAAa,IAAI,kBAAkB,OAAO,KAAK;AACxD,gBAAI,OAAO,mBAAmB;AAC5B,uBAAS,aAAa,IAAI,qBAAqB,OAAO,iBAAiB;AAAA,YACzE;AACA,mBAAO,KAAK,SAAS,SAAS,CAAC;AAAA,UACjC;AACA;AAAA,QACF;AAGA,YAAI,CAAC,OAAO,MAAM;AAChB,gBAAM,gBAA+B;AAAA,YACnC,OAAO;AAAA,YACP,mBAAmB;AAAA,UACrB;AAEA,mBAAS;AAAA,YACP,QAAQ;AAAA,YACR,OAAO;AAAA,YACP,WAAW;AAAA,YACX,WAAW;AAAA,YACX,SAAS;AAAA,UACX,CAAC;AAED,oBAAU,aAAa;AAEvB,cAAI,CAAC,qBAAqB;AACxB,mBAAO,KAAK,GAAG,aAAa,gBAAgB;AAAA,UAC9C;AACA;AAAA,QACF;AAGA,cAAM,cAAc,IAAI,IAAI,sBAAsB,OAAO,SAAS,MAAM;AACxE,oBAAY,SAAS,OAAO,SAAS;AAErC,cAAM,WAAW,MAAM,MAAM,YAAY,SAAS,GAAG;AAAA,UACnD,QAAQ;AAAA,UACR,aAAa;AAAA,QACf,CAAC;AAED,YAAI,CAAC,SAAS,IAAI;AAEhB,cAAI,eAAe;AACnB,cAAI;AACF,kBAAM,YAAY,MAAM,SAAS,KAAK;AACtC,2BAAe,UAAU,qBAAqB,UAAU,SAAS;AAAA,UACnE,QAAQ;AACN,2BAAe,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU;AAAA,UAChE;AAEA,gBAAM,gBAA+B;AAAA,YACnC,OAAO;AAAA,YACP,mBAAmB;AAAA,UACrB;AAEA,mBAAS;AAAA,YACP,QAAQ;AAAA,YACR,OAAO;AAAA,YACP,WAAW;AAAA,YACX,WAAW;AAAA,YACX,SAAS;AAAA,UACX,CAAC;AAED,oBAAU,aAAa;AAEvB,cAAI,CAAC,qBAAqB;AACxB,mBAAO,KAAK,GAAG,aAAa,qBAAqB;AAAA,UACnD;AACA;AAAA,QACF;AAGA,iBAAS;AAAA,UACP,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,WAAW;AAAA,UACX,WAAW;AAAA,UACX,SAAS;AAAA,QACX,CAAC;AAED,oBAAY,MAAM;AAGlB,YAAI,CAAC,qBAAqB;AAExB,gBAAM,mBAAmB,aAAa,IAAI,aAAa,KAAK;AAC5D,iBAAO,KAAK,gBAAgB;AAAA,QAC9B;AAAA,MAEF,SAAS,OAAO;AAEd,cAAM,gBAA+B;AAAA,UACnC,OAAO;AAAA,UACP,mBAAmB,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAC9D;AAEA,iBAAS;AAAA,UACP,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,WAAW;AAAA,UACX,WAAW;AAAA,UACX,SAAS;AAAA,QACX,CAAC;AAED,kBAAU,aAAa;AAEvB,YAAI,CAAC,qBAAqB;AACxB,iBAAO,KAAK,GAAG,aAAa,sBAAsB;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAEA,oBAAgB;AAAA,EAClB,GAAG,CAAC,cAAc,QAAQ,iBAAiB,eAAe,qBAAqB,WAAW,OAAO,CAAC;AAElG,SAAO;AACT;;;AF1NO,SAAS,aAAa;AAC3B,QAAM,EAAE,MAAM,QAAQ,OAAO,IAAI,kBAAkB;AAEnD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAGO,SAAS,UAAU;AACxB,QAAM,EAAE,MAAM,SAAS,QAAQ,OAAO,IAAI,kBAAkB;AAE5D,QAAM,QAAQ,CAAC,eAAwB;AACrC,UAAM,MAAM,IAAI,IAAI,mBAAmB,OAAO,SAAS,MAAM;AAC7D,QAAI,YAAY;AACd,UAAI,aAAa,IAAI,eAAe,UAAU;AAAA,IAChD;AACA,WAAO,SAAS,OAAO,IAAI,SAAS;AAAA,EACtC;AAEA,QAAM,SAAS,CAAC,eAAwB;AACtC,UAAM,MAAM,IAAI,IAAI,oBAAoB,OAAO,SAAS,MAAM;AAC9D,QAAI,YAAY;AACd,UAAI,aAAa,IAAI,eAAe,UAAU;AAAA,IAChD;AACA,WAAO,SAAS,OAAO,IAAI,SAAS;AAAA,EACtC;AAEA,SAAO;AAAA,IACL;AAAA,IACA,MAAM,SAAS,QAAQ;AAAA,IACvB;AAAA,IACA,WAAW,WAAW;AAAA,IACtB,iBAAiB,WAAW;AAAA,IAC5B;AAAA,IACA;AAAA,IACA,SAAS;AAAA,EACX;AACF;AAGO,SAAS,UAAuB;AACrC,QAAM,EAAE,MAAM,QAAQ,IAAI,kBAAkB;AAC5C,SAAO,SAAS,QAAQ;AAC1B;AAGO,SAAS,gBAAgB;AAC9B,QAAM,EAAE,OAAO,IAAI,kBAAkB;AACrC,SAAO;AACT;","names":["useEffect","useState"]}